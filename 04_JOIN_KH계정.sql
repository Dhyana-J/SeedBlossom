/*

@ JOIN?
두 개 이상의 테이블에서 데이터를 조회하고자 할 때 사용되는 구문이다.
조회 결과는 하나의 결과물 (RESULT SET)로 나온다.

RELATIONAL DB(관계형 DB)는 최소한의 데이터를 각각의 테이블에 담고있다. (데이터 중복이 최소화된 테이블)
=> JOIN 구문은 관계형 DB에서 테이블간 "관계"를 맺기 위한 구문!


JOIN은 크게 "ORACLE"과 "ANSI" 구문으로 나뉜다.


        
FROM절에 ','로 구분해 합칠 테이블 명을 기술하고,
WHERE절에 합치기에 쓸 칼럼명을 명시해주자.

*/

--각 사원들의 사번, 사원명, 부서코드, 부서명까지 같이 조회하고 싶을 때?
SELECT EMP_ID, EMP_NAME, DEPT_CODE
FROM EMPLOYEE;

SELECT *
FROM DEPARTMENT,LOCATION
--LEFT JOIN LOCATION ON(LOCATION_ID=LOCAL_CODE)
--WHERE LOCATION_ID = 'L1';
WHERE LOCATION_ID=LOCAL_CODE;


SELECT EMP_ID, EMP_NAME, DEPT_CODE,DEPT_ID, DEPT_TITLE, LOCATION_ID
FROM EMPLOYEE--, DEPARTMENT;
--WHERE DEPT_CODE = DEPT_ID;
--JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID); --기본이 INNER JOIN
FULL OUTER JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID);


SELECT EMP_ID, EMP_NAME, E.JOB_CODE, JOB_NAME
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE=J.JOB_CODE;

SELECT EMP_ID, EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);

SELECT EMP_ID, EMP_NAME, E.JOB_CODE, JOB_NAME
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_CODE=J.JOB_CODE);

SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT;
WHERE DEPT_CODE = DEPT_ID; --DEFAULT가 INNER JOIN임
--WHERE DEPT_CODE(+) = DEPT_ID;
--안붙은 애한테 (+)붙은 애가 얹어진다. 그니까 (+)안붙은애 기준으로 조인이 일어난다. 그럼 ORACLE 구문으로 FULL OUTER는 어떻게하지?

--직급이 대리인 사원의 사번, 사원명, 급여 조회
SELECT JOB_CODE
FROM JOB
WHERE JOB_NAME = '대리';

SELECT EMP_ID, EMP_NAME, SALARY, JOB_NAME, JOB_CODE
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);

---------------------------------<실습문제>-------------------------------------
--1.부서가 인사관리부인 사원들의 사번, 사원명, 보너스를 조회
-->>오라클 및 ANSI 구문 둘 다 써보자. 
--ORACLE
SELECT EMP_NO, EMP_NAME, NVL(BONUS,'0')
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_TITLE = '인사관리부';
--ANSI
SELECT EMP_NO, EMP_NAME, NVL(BONUS,0)
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_TITLE='인사관리부');

--2. 부서가 총무부가 아닌 사원들의 사원명, 급여, 입사일 조회
-->>구문 둘 다 써보자
--ORACLE
SELECT EMP_NAME, SALARY, HIRE_DATE, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID AND DEPT_TITLE !='총무부';
--ANSI
SELECT EMP_NAME, SALARY, HIRE_DATE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID AND DEPT_TITLE !='총무부');

--3. 보너스를 받는 사원들의 사번, 사원명, 보너스, 부서명을 조회
-->> 구문 둘 다
--ORACLE
SELECT EMP_NO, EMP_NAME, BONUS, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID
    AND BONUS IS NOT NULL;

--ANSI
SELECT EMP_NO, EMP_NAME, BONUS, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID)
    AND BONUS IS NOT NULL;


--4. 아래의 두 테이블 참고해서 부서코드, 부서명, 지역코드, 지역명(LOCAL_NAME) 조회하자
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;

--ORACLE
SELECT DEPT_ID, DEPT_TITLE, LOCAL_CODE, LOCAL_NAME
FROM DEPARTMENT, LOCATION
WHERE LOCATION_ID=LOCAL_CODE;
--ANSI
SELECT DEPT_ID, DEPT_TITLE, LOCAL_CODE, LOCAL_NAME
FROM DEPARTMENT
JOIN LOCATION ON (LOCATION_ID=LOCAL_CODE);

-- 사번, 사원명, 부서명, 직급명
SELECT EMP_NO, EMP_NAME, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE E, DEPARTMENT, JOB J
WHERE DEPT_CODE=DEPT_ID AND (E.JOB_CODE = J.JOB_CODE);

SELECT EMP_NO, EMP_NAME, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
RIGHT OUTER JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID); -- LEFT RIGHT 만 써도 알아서 OUTER라고 알아들음

SELECT EMP_NO, EMP_NAME, DEPT_TITLE--JOB_NAME
FROM EMPLOYEE E, DEPARTMENT--, JOB J
WHERE DEPT_CODE(+)=DEPT_ID; -- AND E.JOB_CODE = J.JOB_CODE;
--WHERE DEPT_ID=DEPT_CODE(+) AND E.JOB_CODE = J.JOB_CODE;

-- 2) RIGHT [OUTER] JOIN : 두 테이블 중 오른편에 기술된 테이블을 기준으로 JOIN
-->> ANSI 구문
SELECT EMP_NAME, DEPT_TITLE, SALARY
FROM EMPLOYEE
RIGHT DEPARTMENT ON (DEPT_CODE = DEPT_ID);

SELECT EMP_NAME, DEPT_TITLE, SALARY
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE(+)=DEPT_ID;

--------------------------------------------------------------------------------------

/*
    3. CARTESIAN PRODUCT / CROSS JOIN
    모든 테이블의 각 행들이 서로서로 매핑된 데이터가 조회 (곱집합)
    두 테이블의 행들이 모두 곱해진 행들의 조합이 출력 --> 방대한 데이터 출력 --> 과부화의 위험
*/

-- 사원명, 부서명
-->> 오라클 구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT; --> 23*9 => 207행

-->> ANSI 구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
CROSS JOIN DEPARTMENT;

-----------------------------------------------------

/*
 4. 자체 조인 (SELF JOIN)
*/

SELECT E.EMP_ID, E.EMP_NAME, E.DEPT_CODE, E.MANAGER_ID, M.EMP_NAME
FROM EMPLOYEE E,EMPLOYEE M
WHERE E.MANAGER_ID(+) = M.EMP_ID;

SELECT E.EMP_ID, E.EMP_NAME, E.DEPT_CODE, E.MANAGER_ID, M.EMP_NAME
FROM EMPLOYEE E
LEFT JOIN EMPLOYEE M ON (E.MANAGER_ID = M.EMP_ID);
---------------------------------------------------------------------
--비등가 조인
-- 사원명, 급여
SELECT EMP_NAME, SALARY
FROM EMPLOYEE;

SELECT*
FROM SAL_GRADE;

-- 사원명, 급여, 급여등급(SAL_LEVEL)
-->> 오라클 구문
SELECT EMP_NAME, SALARY, SAL_LEVEL
FROM EMPLOYEE, SAL_GRADE
WHERE SALARY BETWEEN MIN_SAL AND MAX_SAL;

SELECT EMP_NAME, SALARY, SAL_LEVEL
FROM EMPLOYEE
JOIN SAL_GRADE ON (SALARY BETWEEN MIN_SAL AND MAX_SAL);

-------------------------------------------------------------------------

SELECT * FROM EMPLOYEE; -- DEPT_CODE
SELECT * FROM DEPARTMENT; -- DEPT_ID    LOCATION_ID
SELECT * FROM LOCATION; -- LOCAL_CODE

SELECT EMP_ID, EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCATION_ID=LOCAL_CODE);

SELECT EMP_ID, EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE, DEPARTMENT, LOCATION
WHERE DEPT_CODE = DEPT_ID AND LOCATION_ID=LOCAL_CODE;

--------------------------------------------------------------------------------
--사번, 사원명, 부서명, 직급명, 근무지역, 근무국가명, 급여등급 조회
--ORACLE
SELECT EMP_NO 사번,
        EMP_NAME 사원명, 
        DEPT_TITLE 부서명, 
        J.JOB_NAME 직급명, 
        LOCAL_NAME 근무지역, 
        NATIONAL_NAME 근무국가명, 
        SAL_LEVEL 급여등급
FROM EMPLOYEE E, 
        DEPARTMENT D,
        JOB J, 
        LOCATION L, 
        NATIONAL N, 
        SAL_GRADE
WHERE E.DEPT_CODE=D.DEPT_ID 
        AND E.JOB_CODE = J.JOB_CODE
        AND D.LOCATION_ID=L.LOCAL_CODE 
        AND L.NATIONAL_CODE = N.NATIONAL_CODE 
        AND E.SALARY BETWEEN MIN_SAL AND MAX_SAL;
-- ANSI
SELECT EMP_NO 사번,
        EMP_NAME 사원명, 
        DEPT_TITLE 부서명, 
        J.JOB_NAME 직급명, 
        LOCAL_NAME 근무지역, 
        NATIONAL_NAME 근무국가명, 
        SAL_LEVEL 급여등급
FROM EMPLOYEE E
JOIN DEPARTMENT D ON (E.DEPT_CODE=D.DEPT_ID)
JOIN JOB J ON (E.JOB_CODE = J.JOB_CODE)
JOIN LOCATION L ON (D.LOCATION_ID=L.LOCAL_CODE)
JOIN NATIONAL N ON (L.NATIONAL_CODE=N.NATIONAL_CODE)
JOIN SAL_GRADE ON (E.SALARY BETWEEN MIN_SAL AND MAX_SAL);







